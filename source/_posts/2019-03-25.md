---
title: ThreadPoolExecutor 源码分析
date: 2019-03-25 17:09:01
tags:  
    - JAVA
    - 源码分析
    - 线程池
    - 线程
categories: JAVA
comments: true
---

## 线程池的必要性
1、线程是稀缺资源，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用。
2、可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃。

## 线程池的创建
``` java
 /**
     * Creates a new {@code ThreadPoolExecutor} with the given initial
     * parameters.
     *
     * @param corePoolSize the number of threads to keep in the pool, even
     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
     * @param maximumPoolSize the maximum number of threads to allow in the
     *        pool
     * @param keepAliveTime when the number of threads is greater than
     *        the core, this is the maximum time that excess idle threads
     *        will wait for new tasks before terminating.
     * @param unit the time unit for the {@code keepAliveTime} argument
     * @param workQueue the queue to use for holding tasks before they are
     *        executed.  This queue will hold only the {@code Runnable}
     *        tasks submitted by the {@code execute} method.
     * @param threadFactory the factory to use when the executor
     *        creates a new thread
     * @param handler the handler to use when execution is blocked
     *        because the thread bounds and queue capacities are reached
     * @throws IllegalArgumentException if one of the following holds:<br>
     *         {@code corePoolSize < 0}<br>
     *         {@code keepAliveTime < 0}<br>
     *         {@code maximumPoolSize <= 0}<br>
     *         {@code maximumPoolSize < corePoolSize}
     * @throws NullPointerException if {@code workQueue}
     *         or {@code threadFactory} or {@code handler} is null
     */
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```
<!-- more -->
### 参数说明

|参数|说明|
|--- |--- |
|corePoolSize|线程池核心线程数,既至少保持多少线程数量|
|maximumPoolSize|线程池最大线程数|
|keepAliveTime|非核心线程空闲时，保持存活时间|
|unit|非核心线程空闲时，保持存活时间的时间单位|
|workQueue|工作队列，当核心线程使用完后，进入工作队列等待|
|threadFactory|线程创建工厂类|
|handler|当超过最大线程数时，线程池无法执行命令，拒绝处理方式|

### 创建线程池实例
``` java
package com.java8.thread;

import com.google.common.util.concurrent.ThreadFactoryBuilder;

import java.util.concurrent.*;

/**
 * 线程池测试
 *
 * @author zero
 */
public class ThreadPoolTest {

    public static void main(String[] args) throws InterruptedException {

        BlockingDeque<Runnable> blockingDeque = new LinkedBlockingDeque<>(5);
        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
                .setNameFormat("demo-pool-%d").build();
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(3, 6, 3, TimeUnit.SECONDS, blockingDeque, namedThreadFactory);

        for (int i = 0; i < 11; i++) {
            final int k = i;
            threadPoolExecutor.execute(() -> {
                try {
                    System.out.println(k);
                    Thread.sleep(300);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });

            System.out.println("线程池中活跃的线程数： " + threadPoolExecutor.getPoolSize());
            if (blockingDeque.size() > 0) {
                System.out.println("----------------队列中阻塞的线程数" + blockingDeque.size());
            }
        }

        // 空闲线程超时
        Thread.sleep(4000);
        System.out.println("线程池中活跃的线程数： " + threadPoolExecutor.getPoolSize());

        threadPoolExecutor.shutdown();
    }
}

```

执行结果：

``` 
线程池中活跃的线程数： 1
0
线程池中活跃的线程数： 2
1
线程池中活跃的线程数： 3
2
线程池中活跃的线程数： 3
----------------队列中阻塞的线程数1
线程池中活跃的线程数： 3
----------------队列中阻塞的线程数2
线程池中活跃的线程数： 3
----------------队列中阻塞的线程数3
线程池中活跃的线程数： 3
----------------队列中阻塞的线程数4
线程池中活跃的线程数： 3
----------------队列中阻塞的线程数5
线程池中活跃的线程数： 4
----------------队列中阻塞的线程数5
8
线程池中活跃的线程数： 5
----------------队列中阻塞的线程数5
9
线程池中活跃的线程数： 6
----------------队列中阻塞的线程数5
10
3
4
5
6
7
线程池中活跃的线程数： 3
```

### 执行过程
![](http://image.ifamily.wang/2019-03-26-15535688079687.jpg)

## execute方法

### 源码
``` java
    /**
     * (未来某个时间将执行给定的任务，任务可能执行在新的线程或线程池中已存在的线程中)
     * Executes the given task sometime in the future.  The task
     * may execute in a new thread or in an existing pooled thread.
     * （如果已提交的任务无法执行，可能因为执行器已经关闭或已达到其容量，那该任务会被RejectedExecutionHandler处理）
     * If the task cannot be submitted for execution, either because this
     * executor has been shutdown or because its capacity has been reached,
     * the task is handled by the current {@code RejectedExecutionHandler}.
     *
     * @param command the task to execute
     * @throws RejectedExecutionException at discretion of
     *         {@code RejectedExecutionHandler}, if the task
     *         cannot be accepted for execution
     * @throws NullPointerException if {@code command} is null
     */
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * 分3步进行
         * Proceed in 3 steps:
         * (1.如果正在运行的线程少于corePoolSize，则尝试以给定的command启动一个新的线程作为该线程的第一个任务，
         * 调用addWorker原子级别的检查 runState运行状态 和 workerCount 运行数量，
         * 这样能够防止在不能添加线程时返回false的错误警告，注意，addWorker是原子性的操作)
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn't, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         */
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }


``` 


